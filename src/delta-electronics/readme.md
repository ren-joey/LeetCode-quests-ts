## 原始問題
假設在網路上購買了一堆商品，A1,A2,A3,A4,A5,A6,A7,A10,A15,A20,A25,A30
每個商品購買一個，且每個商品都是100元。
商店有套餐福利，滿足購物套餐的物品組，可以打九折。（一個商品只能計算在一個套餐中。）

G1: A1,A2,A3,A4,A5,A6<br>
G2: A1,A2,A50<br>
G3: A1,A2,A3,A4<br>
G4: A5,A10,A20,A30<br>
G5: A5,A6,A10,A15<br>
G6: A20,A30<br>
G7: A20,A25,A30<br>

該如何選擇套餐，讓【付錢最少】？為何您的演算法能有最佳效率？請附上【code + 結果畫面 + 分析您的演算法 Time complexity】，並說明您選擇這樣做法的原因，為何您覺得樣的做法能有最佳效率。<br>
以上述例子來看，最佳套餐選取應該是 G3 + G5 + G7，只會剩下 A7 沒打折

## 實驗設定
為簡化問題，我將商品編號及套餐調整為索引值：<br>
|輸入名稱|實驗設定|範例
|-|-|-|
|商品|由 0 開始的索引值，由一個數字表示該所引的上限|`0, 1, 2`表示為1
|套餐|2維陣列<br>y軸為套餐編號，x軸為套餐商品|`[[0, 1], [1, 2], [2]]`
|解答|1維陣列，表示所有選中套餐的索引值|`[0, 2]`

## 演算法
1. 先計算出若第N個套餐被選取之後，仍然可選的其它套餐放入二維陣列供後面步驟查找，稱作 lookup table(LT)。同時計算出每個套餐的價值(即為該套餐之長度)。
2. 從索引值0的套餐出發，查看 LT
3. 從 LT 中可用的套餐往下查找，假設第二個套餐索引值為1
4. 更新局部 LT 為 LT[0] 與 LT[1] 的交集
5. 若 LT 為空，回傳該套餐的價值，若仍有剩餘，反覆執行 3-5 直到 LT 為空
6. 比較 LT 中所有結果價值取最高者
7. 反覆執行 2-6，值到所有套餐索引都被訪問過
8. 取全部價值最高者

## 時間複雜度
若套餐的數為n，則
- 暴力破解法 O(2^n)
- 該演算法 O(2^n)

### 最差狀況
套餐數非常多且每個套餐的商品重疊較少
- 暴力破解法 O(2^n)
- 該演算法 O(2^n)

### 該例子的情況
- 暴力破解法遞迴次數： 448
- 該演算法遞迴次數： 23 + 49(LT 生成)